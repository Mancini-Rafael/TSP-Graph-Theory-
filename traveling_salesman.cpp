/*
THIS PROGRAM GENERATES THE BEST SOLUTION (LOWEST COST) FOR A HAMILTONIAN CICLE
GIVEN A GRAPH (ALSO KNOWN AS THE TRAVELLING SALESMAN PROBLEM). IT WAS DEVELOPED AS
PART OF THE FINAL PROJECT OF A COLLEGE CLASS BY RAFAEL L MANCINI, LUIS
FERNANDO BEVILACQUA AND VICTORIA PS. IT HAS AN EXACT METHOD GENERATED BY
EXHAUSTION, A EDGE SWAP METHOD AND A SIMMULATED ANNEALING METHOD. THE PROGRAM
TAKES THE GRAPH INFORMATION AS A .IN FILE THAT CAN BE CREATED IN ANY TEXT EDITOR.

LAST UPDATE: 24/11/2016
*/






#include <stdlib.h>
#include <iostream>
#include <string>
#include <list>
#include <fstream>
#include <cstring>
using namespace std;
#include "Graph.h"
#include <vector>
#include <random>
#include <cmath>
#include <chrono>
#include <algorithm>
using ns = chrono::nanoseconds;
using get_time = chrono::steady_clock;


void openFile(string filePath, ifstream& file);
void metodo_exato (Graph graph, vector<string> list_of_paths);
void print_vector (vector<string> list_of_paths);
int findWeightBetween(int origin, int destiny, Graph graph);
void twoOpt(Graph graph);
double calculateDistance(int path[], int pathSize, Graph graph);
int* swap(int i, int k , int path[], int pathSize);
void entre_opcao(Graph graph);
void metodo_heuristico_annealing(Graph graph, vector<string> list_of_paths);
int getweightofTour(std::vector<int> tour, Graph graph);
vector<int> convert_vector_to_array_int (vector<string> v, Graph graph);
vector<int> getNewNeighbour(std::vector<int> tour);
double getRandomNumber(double temp,double dif);
double getProbability(int difference,double temperature);


int main(int argc, char const *argv[]) {
  Graph graph;
  ifstream file;
  openFile("G1.in", file);
  graph.generateFromFile(file);
  graph.print();
  entre_opcao(graph);

  return 0;
}




void metodo_heuristico_annealing(Graph graph, vector<string> list_of_paths){
  vector<int> best_solution;
  vector<int> new_solution;
  double temperature,final_temperature = 10, cooling_rate = 0.99;
  int newtourlength, difference , best_tour_weight, new_tour_weight;
  best_solution = convert_vector_to_array_int (list_of_paths, graph);  //CREATES THE STARTING POINT (RANDOM TOUR)
  random_shuffle(best_solution.begin(), best_solution.end());
  best_tour_weight = getweightofTour(best_solution, graph);
  temperature = 100;


  for(int k=0; k < 100; k++){                               // WILL TRY TO 100 TIMES
    //std::cout << "K = " << k << std::endl;
      new_solution = getNewNeighbour(best_solution);
      new_tour_weight = getweightofTour(new_solution, graph);
      std::cout << "BEST is: " << best_tour_weight << "  New is: "<< new_tour_weight << endl ;
      //std::cout << "Temp: " << temperature << endl ;
      if(new_tour_weight <= best_tour_weight){                  //Garantees that it will try to get to the bottom of the hill before jumping;
        std::cout << "Better" << std::endl;
        temperature = temperature*cooling_rate;
        std::cout << "Temp: " << temperature << endl ;
        best_solution = new_solution;
        best_tour_weight = getweightofTour(best_solution, graph);
        continue;
      } else if(((new_tour_weight - best_tour_weight) >= 0) && (getProbability(difference, temperature) >= getRandomNumber(0,1))){
        best_solution = new_solution;
        best_tour_weight = getweightofTour(best_solution, graph);
        temperature = temperature*cooling_rate;
        std::cout << "Temp: " << temperature << endl ;
        random_shuffle(best_solution.begin(), best_solution.end()); //BUT IF THE HILL ENDS, IT JUMPS HEHEHEHEHEHEH (it's 4am now, I need coffee)
        std::cout << "JUMP " << endl ;
        continue;
      }
      temperature = temperature*cooling_rate;

  }
  cout << "\n\nO custo mínimo de tour é: " << new_tour_weight << endl;
  cout << "O tour com peso mínimo é: ";
  for (vector<int>::const_iterator i = best_solution.begin(); i != best_solution.end(); ++i){
    cout << *i << ' ';
}
}

void metodo_exato (Graph graph, vector<std::string> list_of_paths){
        int numberOfVertices = graph.numberOfVertices;
        int minimunWeight = 1000000;
        vector<std::string> new_vector;
    do {
      int tourWeight = 0;
      for (vector<string>::const_iterator i = list_of_paths.begin(); i != list_of_paths.end(); ++i){
        cout << *i << ' ';

        if(i+1 != list_of_paths.end()){
          tourWeight += findWeightBetween(stoi(*i), stoi(*(i+1)), graph);
        }
        else{
          tourWeight += findWeightBetween(stoi(*i), stoi(*list_of_paths.begin()), graph);
          }

      }
      cout << "O custo desse tour é: " << tourWeight << endl;
      if(tourWeight < minimunWeight){
        minimunWeight = tourWeight;
        new_vector.assign(list_of_paths.begin(),list_of_paths.end());
  }

      } while ( next_permutation(list_of_paths.begin(), list_of_paths.end()) );
    cout << "\n\nO custo mínimo de tour é: " << minimunWeight << endl;
    cout << "O tour com peso mínimo é: ";
      for (vector<string>::const_iterator i = new_vector.begin(); i != new_vector.end(); ++i){
      cout << *i << ' ';
        }
  cout << "\n";
              }

void twoOpt(Graph graph){
  int pathSize = graph.numberOfVertices + 1;
  int path[pathSize];

  for(int i = 0; i < pathSize - 1; i++){
    path[i] = i+1;
  }
  path[pathSize-1] = 1;

  double smallerDistance;
  int improve = 0;

  while ( improve < 2 ){
    smallerDistance = calculateDistance(path, pathSize, graph);

    for ( int i = 0; i < pathSize - 2; i++ ) {
      for ( int k = i + 1; k < pathSize - 1; k++) {
        int newPath[pathSize];

        int j = 0;
        while(j < pathSize){
          if(j>i && j<=k){
            newPath[j] = path[k-(j-i-1)];
          }
          else{
            newPath[j] = path[j];
          }
          j++;
        }

        double newDistance = calculateDistance(newPath, pathSize, graph);

        if ( newDistance < smallerDistance ) {
          improve = 0;
          for(int cp = 0; cp < pathSize; cp++){
            path[cp] = newPath[cp];
          }
          smallerDistance = newDistance;
        }
      }
    }
    improve ++;
  }

  cout << "\nO custo do tour mínimo é: " << smallerDistance << endl;
  cout << "O tour mínimo é: ";
  for(int cp = 0; cp < pathSize; cp++){
    cout << path[cp] << " ";
  }
  cout << endl;
}

/*#######################################################################
                SECONDARY FUNCTIONS & CLASSES
#######################################################################*/

int getweightofTour(vector<int> tour, Graph graph){
  int tourWeight;
  for (vector<int>::const_iterator i = tour.begin(); i != tour.end(); ++i){
        if(i+1 != tour.end()){
      tourWeight += findWeightBetween((*i),(*(i+1)), graph);
        }
    else{
      tourWeight += findWeightBetween((*i),(*tour.begin()), graph);
      }
  }
  return tourWeight;
}

vector<int> convert_vector_to_array_int (vector<string> v, Graph graph){
  std::vector<int> intNumbers;
  for(int i=0; i < graph.numberOfVertices; i++){
    int num = atoi(v.at(i).c_str());
    intNumbers.push_back(num);
  }
  return intNumbers;
}

void entre_opcao(Graph graph){
    int opcao;
  std::cout << "Por favor entre com a opção para resolução do TSP: " << std::endl;
  std::cout << "(1) para método exato." << std::endl;
  std::cout << "(2) para método heurístico Simmulated Annealing" << std::endl;
  std::cout << "(3) para método heurístico Edge Swapping" << std::endl;
  cin >> opcao;
  if(opcao == 1){
    auto start = get_time::now();
    cout << "Você escolheu o método exato." << endl;
    metodo_exato(graph, graph.enderecos_vertices);
    auto end = get_time::now();
    auto diff = end - start;
    cout << "O tempo de execução foi:  " << chrono::duration_cast<ns>(diff).count() << "  nanosegundos" << endl;
    entre_opcao(graph);
  }else if(opcao ==2){
    auto start = get_time::now();
    cout << "Você escolheu o método Simmulated Annealing." << endl;
    metodo_heuristico_annealing(graph, graph.enderecos_vertices);
    auto end = get_time::now();
    auto diff = end - start;
    cout << "O tempo de execução foi:  " << chrono::duration_cast<ns>(diff).count() << "  nanosegundos" << endl;
    entre_opcao(graph);
  }else if(opcao ==3){
    auto start = get_time::now();
    cout << "Você escolheu o método Connection Swapping." << endl;
    twoOpt(graph);
    auto end = get_time::now();
    auto diff = end - start;
    cout << "O tempo de execução foi:  " << chrono::duration_cast<ns>(diff).count() << "  nanosegundos" << endl;
    entre_opcao(graph);
  }
  else{
    cout << "Essa opção não é valida. Tente novamente" << endl;
    entre_opcao(graph);
  }

}

int* swap(int i, int k , int path[], int pathSize){
  int j = 0;
  int newPath[pathSize];
  while(j < pathSize){
    if(j>i && j<=k){
      newPath[j] = path[pathSize - j];
    }
    else{
      newPath[j] = path[j];
    }
  }
  return newPath;
}

double calculateDistance(int path[], int pathSize, Graph graph){
  double distance = 0;

  for(int i = 0; i < pathSize-1; i++){
    distance += findWeightBetween(path[i],path[i+1],graph);
  }
  return distance;
}

void openFile(string filePath, ifstream& file){
  file.open(filePath.c_str());
  cout << "File opened." << endl;
  if (!file.is_open()){
    cout << "Erro ao abrir o arquivo \"" << filePath << "\"" << endl;
  }
}

int findWeightBetween(int originId, int destinyId, Graph graph){
  Vertex origin = graph.vertices[originId];

  std::list<int>::iterator weight = origin.adjacenciesWeight.begin();
  std::list<int>::iterator id = origin.adjacenciesId.begin();

  while(id != origin.adjacenciesId.end()){
    if(destinyId == *id){
      return *weight;
    }
    id++;
    weight++;
  }
}

vector<int> getNewNeighbour(std::vector<int> tour){
  iter_swap(tour.begin() + int(getRandomNumber(tour.size(), tour.size() - 5 )) , tour.begin() + int(getRandomNumber(tour.size(), tour.size() - 2 )) );
  return tour;
}

double getRandomNumber(double temp,double dif){ //This function generates a random number between

  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
  default_random_engine generator (seed);
  uniform_real_distribution<double> distribution (temp,dif);
  return double(distribution(generator));

}

double getProbability(int difference,double temperature){ //This function finds the probability of how bad the new solution is

  return exp(-1*difference/temperature);
}
